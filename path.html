<!DOCTYPE html>
<html>
<head>
  <title></title>
<style type="text/css">

  .hidden{
    display:none;
  }
  *:not(input):not(textarea) {
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }
  path{
  	pointer-events: visible;
  }
  .hl{
  	stroke-width:6px;
  	stroke-dasharray: 20,5,5,5;
    cursor: -webkit-grabbing;
  }
  .selectState, .selectState .hl{
      cursor: crosshair!important;
  }


</style>
</head>
<body>

<svg width="1640" height='1640' class="canvas">

<defs>
<marker id="triangle" preserveAspectRatio="xMinYMin meet"
  viewBox="0 0 100 100" refX="50" refY="50"
  markerUnits="userSpaceOnUse"
  stroke="#f00"
  fill="#f00"
  stroke-linecap="round"
  stroke-width="10"
  stroke-linejoin="bevel"
  markerWidth="40" markerHeight="30"
  orient="auto">
  <path d="M 0 0 L 100 50 L 0 100 L 30 50 z" />
</marker>
</defs>

<rect id="selrect" style="display:none; stroke:#999; stroke-width:1; stroke-dasharray:10,5; fill:none;" />
<path  id="spline" stroke="#000" fill="none" d=""  />

<!-- <path stroke="#000" stroke-width="2" fill="none" d="M20,380 R58,342 100,342 100,300 140,250 190,210 220,197 250,184 280,155 310,260 404,20"/> -->

</svg>

  <script type="text/javascript" src="zepto.js"></script>
  <script type="text/javascript" src="catmullrom2bezier.js"></script>
  <script type="text/javascript" src="curve_calc.js"></script>
  <script type="text/javascript">
    var svgns = "http://www.w3.org/2000/svg";
    var path = document.getElementById("spline");
    var d = "";
    var i = 0;
    var downX, downY, downTimer;
    var rPath=[];
    var DOT_DISTANCE=10;
    var DRAW_TOLERANCE=10;
    var drawing = false;
    var dragging = false;
    var selecting = false;
    var selectedList = [];

    var isTouch = ('ontouchstart' in window) || ('DocumentTouch' in window && document instanceof DocumentTouch);
    var downE = isTouch? 'touchstart' :'mousedown';
    var moveE = isTouch? 'touchmove' :'mousemove';
    var upE = isTouch? 'touchend' :'mouseup';
    var leaveE = isTouch? 'touchcancel' :'mouseleave';

    NodeList.prototype.forEach = Array.prototype.forEach;

    document.documentElement.style.webkitUserSelect='none';
    document.documentElement.style.webkitTouchCallout='none';

    window.addEventListener(moveE, moveFunc )
    window.addEventListener(downE, downFunc )
    window.addEventListener(upE, upFunc )

    function calcDist (a,b) {
      return Math.sqrt( Math.pow(a[0]-b[0], 2) + Math.pow(a[1]-b[1], 2) );
    }

    function  hideDot (hide) {
      // hide:undefined = toggle, hide:false = show, hide:true = hide;
      var c = document.querySelectorAll('circle.hint');
      for(var j=0;j<c.length; j++){
        if(typeof hide=='undefined') c[j].classList.toggle('hidden');
        if(hide==false) c[j].classList.remove('hidden');
        if(hide==true) c[j].classList.add('hidden');
      }
    }

    function downFunc (e) {
      e.preventDefault();
   	  var evt = /touch/.test(e.type) ? e.touches[0] : e;
   	  var x = evt.pageX;
   	  var y = evt.pageY;
      var isShape = $(evt.target).hasClass('shape');

   	  downX = evt.pageX;
   	  downY = evt.pageY;


      if(e.shiftKey && isShape && $('.shape.hl').length ){
        $(evt.target).toggleClass('hl');
        return;
      }

   	  // long click to trigger dragging mode && selecting mode
      if(!selecting)
   	  downTimer = window.setTimeout(function() {
        //we are longclick on shape
        if( isShape ){
     	  	addSelectionList(evt.target);
     	  	dragging = true;
          $('.shape.hl').each(function  (i,v) {
            $(v).attr('data-oldTrans', getTranslateXY(v).join(',') );
          });
        }else{
          //we are longclick on SVG, selection mode
          downTimer = window.setTimeout(function() {
            selecting=true;
            $('svg.canvas').addClass('selectState');
          },300);
        }
   	  }, 100);


   	  if( $(evt.target).hasClass('hl') ){

   	  	dragging = true;
   	  	$('.shape.hl').each(function  (i,v) {
          $(v).attr('data-oldTrans', getTranslateXY(v).join(',') );
        });

   	  }else {

   	  	dragging = false;

        if(!e.shiftKey)
   	  	document.querySelectorAll('.shape').forEach(function(v){
   	  		$(v).removeClass('hl');
   	  	});

   	  }

    }

    function moveFunc(e)
    {

      e.preventDefault();
      var evt = /touch/.test(e.type) ? e.touches[0] : e;
      var x = evt.pageX;
      var y = evt.pageY;
      var dx = x-downX;
      var dy = y-downY;
      var isShape = $(evt.target).hasClass('shape');

	    var dist = downX&&downY && calcDist([downX, downY], [x,y]) || 0;

      if( dist>10 ) clearTimeout(downTimer);

      if(e.shiftKey && ( !isTouch? e.which>0 : e.touches.length>0 ) ){
        selecting = true;
      } 

      if(selecting && dist>10){

        var svg=document.querySelector('svg.canvas');
        var r = svg.createSVGRect();

        r.width = Math.abs(dx);
        r.height = Math.abs(dy);
        r.x = dx>0? downX : downX+dx;
        r.y = dy>0? downY : downY+dy;

         $('svg.canvas').addClass('selectState');
        $('#selrect').show().attr({x:r.x, y:r.y, width:r.width, height:r.height});

        $('.shape').filter(function(i,v){ return $(this).attr('newHL') }).removeClass('hl');

        var els = svg.getIntersectionList(r, null);
        els.forEach(function(v){
          if( $(v).hasClass('shape') ) addSelectionList(v, true);
        });
        return;

      }

      if(!e.shiftKey)
      if( dragging ){

	      	$('.shape.hl').each(function  (i,v) {
            var oldTrans = $(v).attr('data-oldTrans');
            oldTrans= !oldTrans?[0,0]:oldTrans.split(',');
            var tx = dx+ ~~oldTrans[0];
            var ty = dy+ ~~oldTrans[1];
            $(v).attr("transform", "translate("+ tx +","+ ty +")");
          });
          

      }else{


	      if( !drawing && dist >DRAW_TOLERANCE ){
	    	  drawing = true;
		      rPath=[];
	      }

	      if(!drawing)return;

	      var L = rPath.length;

	      if(L && calcDist(rPath[L-1], [x, y])<DOT_DISTANCE )return;
	      var el = document.createElementNS(svgns, "circle");
	      el.setAttribute( "class", 'hint' );
	      el.setAttribute( "cx", x );
	      el.setAttribute( "cy", y );
	      el.setAttribute( "r", "3" );
	      el.setAttribute( "fill", "red" );
	      document.querySelector('svg.canvas').appendChild( el );

	      rPath.push( [x, y] );


      }



    }

    function upFunc (e) {

    	//init
    	e.preventDefault();
    	var evt = /touch/.test(e.type) ? e.changedTouches[0] : e;
    	downX=downY=null;

    	clearTimeout(downTimer);
      
      if(selecting){
        selecting = false;
        $('#selrect').hide();
        $('svg.canvas').removeClass('selectState');
        $('.shape').removeAttr('newHL');
        return;
      }

    	// just click, no motion
    	if( e.shiftKey && !dragging && !drawing && $('.shape.hl').length==0 ) {
    		if( $(evt.target).hasClass('shape') ) addSelectionList(evt.target);
    		return;
    	}


    	if(dragging){
    		dragging=false;
    	}

	    if(drawing){

	    	// yes motion, drawing path
	      drawing = false;

	      var x = evt.pageX;
	      var y = evt.pageY;

	      var L = rPath.length;

	      var t, d='';
	      var startP = rPath[0];
	      var endP = startP;


	      if(!rPath || !L) return;


	      for(var i=0; i<rPath.length; i++){
	        var p=rPath[i];

	        if ( 0 == i ) {
	          d = "M" + p[0] + "," + p[1];
	        } else if ( 1 == i ) {
	          d += " R" + p[0] + "," + p[1];
	        } else {
	          d += " " + p[0] + "," + p[1];
	        }
	      }

	      //Auto Close:
	      if( L>5 )

	      if( calcDist(startP, p)<50  ){ // &&
	        //drawing rect LineTo way.
	        d+=" M" + p[0] + "," + p[1];
	        d+=" L" + startP[0] + "," + startP[1];
	      } else {
	          //drawing circle Curve way.
	          d += calcInterpo(rPath, 10);
	          //rPath = rPath.concat( _interpo.slice(1) );
	      }

        d = parsePath( d,true, 10 );
      if( !/undefined|NaN/.test(d) )
      try{
          hisAction.push('Path', 'add', d);
		  }catch(e){

		  }
	      //path.setAttribute("marker-end", "url(#triangle)" );
	      document.querySelectorAll('circle.hint').forEach(function  (v) {
	        v.parentNode.removeChild(v);
	      });
	  }


    }


    window.addEventListener('keydown', handleShortKey);

    function handleShortKey (evt) {
      var handled = false;
      var cmd = (evt.ctrlKey ? 1 : 0) |
            (evt.altKey ? 2 : 0) |
            (evt.shiftKey ? 4 : 0) |
            (evt.metaKey ? 8 : 0);

      if (cmd === 0) { // no control key pressed at all.
        switch (evt.keyCode) {
          case 8:  //delete key : Delete the shape
            var el = $('.shape.hl');
            if( el.length ){
              el.remove();
            }
        }
      }

    }


    var hisAction = new function () {
      var hisList = [];
      var hisPos = -1;
      this.push = function( target, action ){
        if( !arguments.length ) return;

        var _id = +new Date()+Math.random();
        var _options = Array.prototype.slice.call(arguments, 2);
        // 4 Global args: action[string], target, _id[decimal], _options[array]
        var his = {action:action, target:target, options:_options, id:_id}

        hisList.splice(++hisPos);
        hisList.push(his);
        
        eval(his.target)[his.action].do(his);

      };

      this.undo = function  () {
        if(hisPos < 0)return;
        var his = hisList[hisPos];
        hisPos--;
        eval(his.target)[his.action].undo(his);
      }

      this.redo = function  () {
        if(hisPos+1>= hisList.length)return;
        hisPos++;
        var his = hisList[hisPos];
        eval(his.target)[his.action].do(his);
      }

      var Path = {
        //each operation is object[2], [0]is redo, [1]is undo
        add:
        {
          do: function  (his) {
            var d = his.options[0];
            this.path = createPath();
            this.path.setAttribute("d", d );
            this.path.setAttribute("data-hisID", his.id );
          },
          undo: function  (his) {
            $('path').filter(function(){ return this.dataset.hisID==his.id }).remove();
          }
        },
        remove:{
          do: function (his) {
            var el = $('.shape.hl');
            if( el.length ){
              el.hide();
            }
          }
        }
      }

    };


    function createPath () {
      var el = document.createElementNS(svgns, "path");
      el.setAttribute( "class", 'shape' );
      el.setAttribute( "stroke", "#F00" );
      el.setAttribute( "stroke-width", '2' );
      el.setAttribute( "fill", "none" );
      document.querySelector('svg.canvas').appendChild( el );
      path = el;
      return el;
    }

    function addSelectionList (el, isNew) {
      if( $(el).hasClass('hl') )return;
      $(el).addClass('hl');
      $(el).attr('data-oldTrans', getTranslateXY(el).join(',') );
      if(isNew) $(el).get(0).setAttribute('newHL', 1);
    }

    function getTranslateXY(obj)
    {
        var style = obj.style, transform = style.transform || style.webkitTransform || style.mozTransform;
        var transform =obj.getAttribute('transform');
        if(!transform) return [0,0];
		var zT = transform.match(/translate\(\s*([-0-9]+[\w%]*)\s*,\s*([-0-9]+[\w%]*)\s*\)/);
        return zT ? [ parseInt(zT[1]), parseInt(zT[2]) ] : [0,0];
    }

    function calcInterpo (rPath, tension) {
      //interpolation using Curve to close the path.
      //https://github.com/epistemex/cardinal-spline-js
      var d="";
      var L=rPath.length;
      var _seg=2;
      var _tension= tension||0;
      var _ps = Math.floor(L/2);
      var points=[];

      for(var c=0, i=_ps; !(c>0 && i>_ps) ; i++) {
        if(i==L){
          c++;
          i=0;
        }
        points.push( rPath[i][0], rPath[i][1] );
      }
      var res = getCurvePoints( points, _tension, _seg );

      var _resStart = (_ps-1+L%2)*_seg*2 ;
      var _resLen = _seg*2;

      var _interpo=[]
      for(var i = _resStart; i <= _resStart+_resLen; i += 2){
        _interpo.push([ res[i], res[i+1] ]);
      }

      d+=" C"+_interpo[1][0]+","+_interpo[1][1];
      d+=" "+_interpo[1][0]+","+_interpo[1][1];
      d+=" "+_interpo[2][0]+","+_interpo[2][1];
      return d;
      //end of interpo
    }


  </script>

</body>
</html>