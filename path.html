<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="content-type" />
  <title></title>
<style type="text/css">

  .hidden{
    display:none;
  }
  *:not(input):not(textarea){
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }

  .unselectable {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
      user-select: none;
  }

  path{
  	pointer-events: visible;
  }
  [data-hl]{
  	stroke-dasharray: 20,15;
    cursor: -webkit-grabbing;
  }
  .selectState, .selectState [data-hl]{
      cursor: crosshair!important;
  }
  #drawTool{
    position: fixed;
    bottom: 0;
    left: 0;
    height: 30px;
    width: 100%;
    overflow: visible;
  }
  .subtool{
    position: absolute;
    bottom: 50px;
    left: 0;
    height: 30px;
  }
  button{
    height:44px;
    width:88px;
  }
  #textCon{
    position: absolute;
    overflow: visible;
  }
  #textCon .text{
    position: absolute;
  }

</style>
</head>
<body>

<div id="svgCon">
  
  <svg width="1640" height='1640' class="canvas" xmlns="http://www.w3.org/2000/svg" version="1.1">
    <defs>
    <marker id="triangle" preserveAspectRatio="xMinYMin meet"
      viewBox="0 0 100 100" refX="50" refY="50"
      markerUnits="userSpaceOnUse"
      stroke="#f00"
      fill="#f00"
      stroke-linecap="round"
      stroke-width="10"
      stroke-linejoin="bevel"
      markerWidth="40" markerHeight="30"
      orient="auto">
      <path d="M 0 0 L 100 50 L 0 100 L 30 50 z" />
    </marker>
    </defs>
    <rect id="selrect" style="display:none; stroke:#999; stroke-width:1; stroke-dasharray:10,5; fill:none;" />

  </svg>
</div>

<div id="textCon" class="canvas">
</div>

<div id="drawTool">
<div class="maintool">
  <button class="btnCurve" data-onclick="setTool('curve')">绘制</button>
  <button class="btnLine" data-onclick="setTool('line')">直线</button>
  <button class="btnRect" data-onclick="setTool('rect')">矩形</button>
  <button class="btnCircle" data-onclick="setTool('circle')">圆形</button>
  <button class="btnText" data-onclick="setTool('text')">文字</button>
  <button class="btnRedo" data-onclick="OPHistory.redo()">Redo</button>
  <button class="btnUndo" data-onclick="OPHistory.undo()">Undo</button>
</div>

<div class="subtool subtool_curve">
  <button class="btnArrow1" data-onclick='setTool("curve", { "toggle":{"arrow": 1} } )'>前箭头</button>
  <button class="btnArrow2" data-onclick='setTool("curve", { "toggle":{"arrow": 2} } )'>后箭头</button>
  <button class="btnAutoClose1" data-onclick='setTool("curve", {"toggle": {"autoClose":1} } )'>直线封闭</button>
  <button class="btnAutoClose2" data-onclick='setTool("curve", {"toggle": {"autoClose":2} } )'>曲线封闭</button>
  <button class="btnStrokeWidth2" data-onclick='setTool("curve", {"stroke-width": "-"} )'>小</button>
  <button class="btnStrokeWidth6" data-onclick='setTool("curve", {"stroke-width": "+"} )'>大</button>
  <button class="btnStroke" data-onclick='setTool("curve", {"stroke": "#f0f"} )'>颜色</button>
</div>

<div class="subtool subtool_line">
  <button class="btnArrow1" data-onclick='setTool("line", {"toggle": {"arrow":1} })'>前箭头</button>
  <button class="btnArrow2" data-onclick='setTool("line", {"toggle": {"arrow":2} })'>后箭头</button>
  <button class="btnArrow2" data-onclick='setTool("line", {"toggle": {"highLight":1}, "stroke":"#f0f"})'>荧光笔</button>
  <button class="btnStrokeWidth2" data-onclick='setTool("line", {"stroke-width": "-"})'>小</button>
  <button class="btnStrokeWidth6" data-onclick='setTool("line", {"stroke-width": "+"})'>大</button>
  <button class="btnStroke" data-onclick='setTool("line", {"stroke": "#f0f"})'>颜色</button>
</div>

<div class="subtool subtool_rect">
  <button class="btnStrokeWidth2" data-onclick='setTool("rect", {"stroke-width": "-"})'>小</button>
  <button class="btnStrokeWidth6" data-onclick='setTool("rect", {"stroke-width": "+"})'>大</button>
  <button class="btnStroke" data-onclick='setTool("rect", {"stroke": "#f0f"})'>颜色</button>
</div>

<div class="subtool subtool_circle">
  <button class="btnStrokeWidth2" data-onclick='setTool("circle", {"stroke-width": "-"})'>小</button>
  <button class="btnStrokeWidth6" data-onclick='setTool("circle", {"stroke-width": "+"})'>大</button>
  <button class="btnStroke" data-onclick='setTool("circle", {"stroke": "#f0f"})'>颜色</button>
</div>


</div>




  <script type="text/javascript" src='undoredo.js'></script>

  <script type="text/javascript" src="zepto.js"></script>
  <script type="text/javascript" src="catmullrom2bezier.js"></script>
  <script type="text/javascript" src="curve_calc.js"></script>
  <script type="text/javascript">
    var svgns = "http://www.w3.org/2000/svg";
    var curShapeID = null;
    var d = "";
    var i = 0;
    var downX, downY, downTimer, prevTime=0;
    var rPath=[];
    var DOT_DISTANCE=10;
    var DRAW_TOLERANCE=10;
    var drawing = false;
    var dragging = false;
    var selecting = false;
    var selectedList = [];
    var curTool = null;
    var prevFocus = null;

    var isTouch = ('ontouchstart' in window) || ('DocumentTouch' in window && document instanceof DocumentTouch);
    var downE = isTouch? 'touchstart' :'mousedown';
    var moveE = isTouch? 'touchmove' :'mousemove';
    var upE = isTouch? 'touchend' :'mouseup';
    var leaveE = isTouch? 'touchcancel' :'mouseleave';

    var ToolSet = {
      curve:{
        "stroke-width": 2,
        "stroke":"#f00",
        "autoClose":0,
        "arrow":0,
      },
      line:{
        "stroke-width": 2,
        "stroke":"#f00",
        "autoClose":0,
        "highLight":false,
        "arrow":0,
      },
      rect:{
        "stroke-width": 2,
        "stroke":"#f00",
      },
      circle:{
        "stroke-width": 2,
        "stroke":"#f00",
      },
      text:{
        "font-family": "Arial",
        "font-size": 36,
        "fill":"red",
      }
    }



    function init () {
      setTool('curve');
      var pos = $('#svgCon').offset();
      $('#textCon').css({ left:pos.left+'px', top:pos.top+'px', width:0+'px', height:0+'px' });
    }
    init();

    function getOptions (oldOptions, setOptions) {
      // oldOptions parameter pass by ref

      //setOptions by value
      var options = $.extend({}, setOptions);

      var toggle = options.toggle;
      var set = options.set;
      var clear = options.clear;

      if( toggle ){ 
        if(toggle.arrow) oldOptions.arrow ^= toggle.arrow;  //bit flip
        if(toggle.highLight) oldOptions.highLight ^= toggle.highLight;  //bit flip
        if(toggle.autoClose){
          //for autoclose, we clear all other bit and flip only this bit
          oldOptions.autoClose = bit_check(oldOptions.autoClose, toggle.autoClose)?0:toggle.autoClose;
        }
        delete options.toggle;
      }

      {
        var swidth = options['stroke-width'];
        delete options['stroke-width'];
        if(swidth=='-') oldOptions['stroke-width'] -= 2;
        if(swidth=='+') oldOptions['stroke-width'] += 2;
        oldOptions= $.extend(oldOptions, options );
      }

      return true;
      
    }

     

    function setTool (tool, options) {
      
      if(!options) options={};
      
      curTool = tool;

      $('#drawTool .subtool').hide();
      $('#drawTool .subtool_'+tool).show();

      var shapeA = [];
      if( $('[data-hl]').size() ){
        shapeA = $('[data-hl]').toArray();
      }else {
        getOptions(ToolSet[tool], options );

        /*
          prevent remember last shape
        */
        //shapeA = $('[data-id="'+ curShapeID +'"]').toArray();
      }

      var isDirty = false;
      shapeA.forEach(function  (v) {
        var oldOptions = v.dataset.options;
        var newOptions = oldOptions ? JSON.parse( oldOptions ) : ToolSet[tool];

        getOptions(newOptions, options );

        if( oldOptions == JSON.stringify(newOptions) ) return true;

        var isCommon = /stroke/.test( Object.keys(newOptions).join(',') );

        //if( tool!=v.dataset.tool ) return true;

        var path = v.dataset.path;
        var start = v.dataset.startpoint;
        var end = v.dataset.endpoint;
        var vTool = v.dataset.tool;

        if( path)
        if(vTool=='curve' ){
          var rPath = JSON.parse(path);
          createPath(rPath, v, newOptions);
        }

        if( start && end )
        if(vTool=='line' ){
          
          var startPoint = JSON.parse(start);
          var endPoint = JSON.parse(end);
          createLine(startPoint, endPoint, v, newOptions);

        }
        
        if( start && end )
        if(vTool=='rect' ){

          var startPoint = JSON.parse(start);
          var endPoint = JSON.parse(end);
          createRect(startPoint, endPoint, v, newOptions);

        }

        if( start && end )
        if(vTool=='circle' ){

          var startPoint = JSON.parse(start);
          var endPoint = JSON.parse(end);
          createCircle(startPoint, endPoint, v, newOptions);

        }

        if( start && end )
        if(vTool=='text' ){

          var startPoint = JSON.parse(start);
          var endPoint = JSON.parse(end);
          createText(startPoint, endPoint, v, newOptions);

        }


        isDirty = true;
      });
      if(isDirty) svgHistory.update();
    }

    

    NodeList.prototype.forEach = Array.prototype.forEach;

    document.documentElement.style.webkitUserSelect='none';
    document.documentElement.style.webkitTouchCallout='none';

    $('button').on(downE, function  (e) {
      e.stopPropagation();
      var evt = /touch/.test(e.type) ? e.touches[0] : e;
      eval(evt.target.dataset.onclick);
    } )

    window.addEventListener(moveE, moveFunc )
    window.addEventListener(downE, downFunc )
    window.addEventListener(upE, upFunc )

    function calcDist (a,b) {
      return Math.sqrt( Math.pow(a[0]-b[0], 2) + Math.pow(a[1]-b[1], 2) );
    }

    function makeShape(tag, attrs) {
        var el= document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (var k in attrs)
            el.setAttribute(k, attrs[k]);
        return el;
    }

    function  hideDot (hide) {
      // hide:undefined = toggle, hide:false = show, hide:true = hide;
      var c = document.querySelectorAll('circle.hint');
      for(var j=0;j<c.length; j++){
        if(typeof hide=='undefined') c[j].classList.toggle('hidden');
        if(hide==false) c[j].classList.remove('hidden');
        if(hide==true) c[j].classList.add('hidden');
      }
    }

    function downFunc (e) {
      //e.preventDefault();
   	  var evt = /touch/.test(e.type) ? e.touches[0] : e;
      
      if( !$(evt.target).is('.text')  ) $('.text').blur();

   	  var x = evt.pageX;
   	  var y = evt.pageY;
      var isShape = $(evt.target).hasClass('shape');

   	  downX = evt.pageX;
   	  downY = evt.pageY;

      if(e.shiftKey && isShape && $('[data-hl]').length ) {
        var d = $(evt.target).data('hl');
        $(evt.target).data('hl', d?null:1);
        return;
      }

      if(e.timeStamp - prevTime<500){
        selecting=true;
        $('svg.canvas').addClass('selectState');
        prevTime = 0;
        return;
      }
      prevTime = e.timeStamp;

   	  // long click to trigger dragging mode && selecting mode
      if(!selecting)
   	  downTimer = window.setTimeout(function() {
        //we are longclick on shape
        if( isShape ){
     	  	addSelectionList(evt.target);
     	  	dragging = true;
          $('[data-hl]').each(function  (i,v) {
            $(v).attr('data-oldTrans', getTranslateXY(v).join(',') );
          });
        }else{
          //we are longclick on SVG, selection mode
          downTimer = window.setTimeout(function() {
            selecting=true;
            $('svg.canvas').addClass('selectState');
          },100);
        }
   	  }, 200);


   	  if( $(evt.target).data('hl') ){

   	  	dragging = true;
   	  	$('[data-hl]').each(function  (i,v) {
          $(v).attr('data-oldTrans', getTranslateXY(v).join(',') );
        });

   	  } else {

   	  	dragging = false;

        if(!e.shiftKey)
   	  	document.querySelectorAll('.shape').forEach(function(v){
          $(v).data('hl',null);
   	  	});

   	  }

    }

    function moveFunc(e)
    {

      e.preventDefault();
      var evt = /touch/.test(e.type) ? e.touches[0] : e;

      //if( ! $(evt.target).closest('.canvas').size() ) return;

      var x = evt.pageX;
      var y = evt.pageY;
      var dx = x-downX;
      var dy = y-downY;
      var isShape = $(evt.target).hasClass('shape');

	    var dist = downX&&downY && calcDist([downX, downY], [x,y]) || 0;

      if( dist>10 ){
        prevTime = 0;
        clearTimeout(downTimer);
      }

      if( !$(evt.target).is('.text') && dist>10  )  disableSelection($('.text'));

      if(!drawing && !dragging && $('[data-hl]').size() && e.shiftKey && ( !isTouch? e.which>0 : e.touches.length>0 ) ){
        selecting = true;
      }

      if(selecting && dist>10){

        var svg=document.querySelector('svg.canvas');
        var r = svg.createSVGRect();

        r.width = Math.abs(dx);
        r.height = Math.abs(dy);
        r.x = dx>0? downX : downX+dx;
        r.y = dy>0? downY : downY+dy;

         $('svg.canvas').addClass('selectState');
        $('#selrect').show().attr({x:r.x, y:r.y, width:r.width, height:r.height});

        $('.shape').filter(function(i,v){ return $(this).attr('newHL') }).data('hl', null);

        var els = svg.getIntersectionList(r, null);
        els.forEach(function(v){
          if( $(v).hasClass('shape') ) addSelectionList(v, true);
        });
        return;

      }

      //if(!e.shiftKey)
      if( dragging ){

	      	$('[data-hl]').each(function  (i,v) {
            var oldTrans = $(v).attr('data-oldTrans');
            oldTrans= !oldTrans?[0,0]:oldTrans.split(',');
            var tx = dx+ ~~oldTrans[0];
            var ty = dy+ ~~oldTrans[1];
            $(v).attr("transform", "translate("+ tx +","+ ty +")");
          });
          

      }else{


        if(curTool=='curve'){

  	      if( !drawing && dist >DRAW_TOLERANCE ){
  	    	  drawing = true;
  		      rPath=[];
  	      }

  	      if(!drawing)return;

  	      var L = rPath.length;

  	      if(L && calcDist(rPath[L-1], [x, y])<DOT_DISTANCE )return;
          var el = makeShape("circle", { class:"hint", cx:x, cy:y, r:3, fill:"red" });
  	      document.querySelector('svg.canvas').appendChild( el );

  	      rPath.push( [x, y] );

        }

        if(curTool=='line'){

          if( !drawing && dist >DRAW_TOLERANCE ){
            drawing = true;
            createLine([downX, downY], [x,y]);
          }
          if(!drawing)return;

          var line = document.querySelector('[data-id="'+ curShapeID +'"]');
          createLine([downX, downY], [x,y], line);
          

        }

        if(curTool=='rect'){

          if( !drawing && dist >DRAW_TOLERANCE ){
            drawing = true;
            createRect([downX, downY], [x,y]);
          }
          if(!drawing)return;

          var rect = document.querySelector('[data-id="'+ curShapeID +'"]');
          createRect([downX, downY], [x,y], rect);
          

        }

        if(curTool=='circle'){

          if( !drawing && dist >DRAW_TOLERANCE ){
            drawing = true;
            createCircle([downX, downY], [x,y]);
          }
          if(!drawing)return;

          var circle = document.querySelector('[data-id="'+ curShapeID +'"]');
          createCircle([downX, downY], [x,y], circle);
          
        }

        if(curTool=='text'){
          if( !drawing && dist >DRAW_TOLERANCE ){
            drawing = true;
          }
          if(!drawing)return;
        }


      }

    }

    function upFunc (e) {

    	//init
    	//e.preventDefault();
    	var evt = /touch/.test(e.type) ? e.changedTouches[0] : e;

    	downX=downY=null;

      var x = evt.pageX;
      var y = evt.pageY;

    	clearTimeout(downTimer);

       enableSelection($('.text'));
      
      if(selecting){
        selecting = false;
        $('#selrect').hide();
        $('svg.canvas').removeClass('selectState');
        $('.shape').removeAttr('newHL');
        return;
      }

    	// just click, no motion
    	if( e.shiftKey && !dragging && !drawing && $('[data-hl]').length==0 ) {
    		if( $(evt.target).hasClass('shape') ) addSelectionList(evt.target);
    		return;
    	}


    	if(dragging){
    		dragging=false;
        svgHistory.update();
        return;
    	}



      if(curTool=='text' && !drawing && !dragging && 
        !$(document.activeElement).is('.text') && 
        //( !prevFocus || !prevFocus.is('.text') ) &&
        !$('.editing').size()  ){

        var $curText = $( document.elementFromPoint(x,y) ).closest('.text');
        if( $curText.size() ){
          

        } else {

          createText([downX, downY], [x,y]);
          
        }

      }
      prevFocus = $(document.activeElement);

	    if(drawing){

	    	// yes motion, drawing path
	      drawing = false;


        if(curTool=='curve'){


          createPath(rPath);

          document.querySelectorAll('circle.hint').forEach(function  (v) {
            v.parentNode.removeChild(v);
          });

        }
   


         svgHistory.update();

      }

    }


    window.addEventListener('keydown', handleShortKey);

    function handleShortKey (evt) {
      var handled = false;
      var cmd = (evt.ctrlKey ? 1 : 0) |
            (evt.altKey ? 2 : 0) |
            (evt.shiftKey ? 4 : 0) |
            (evt.metaKey ? 8 : 0);

      if (cmd === 0) { // no control key pressed at all.
        //console.log(evt.keyCode);
        switch (evt.keyCode) {
          case 8:  //delete key : Delete the shape
            var el = $('[data-hl]');
            if( el.length ){
              el.remove();
              svgHistory.update();
            }
        }
      }

    if (cmd === 1 || cmd === 8) {
      switch (evt.keyCode) {
        case 90:
          OPHistory.undo();
          break;
      }
    }

    if (cmd === 5 || cmd === 12) {
      switch (evt.keyCode) {
        case 90:
          OPHistory.redo();
          break;
      }
    }

    }


  var svgHistory = new function(html) {
    var self = this;
    this.html = $('#svgCon').html();

    //here is an action we cant to be able to undo/redo
    this.update = function() {

        //this variable will be saved in the undo function's closure
        var oldHtml = self.html;
        var newHtml = $('#svgCon').html();

        //self function sets up the action and performs it
        OPHistory.do( 
            //the 'do' or 'redo' function
            function() {
              self.html = newHtml;
              $('#svgCon').html(newHtml);
            }, 

            //the 'undo' function
            function() {
              self.html = oldHtml;
                $('#svgCon').html(oldHtml);
        });
      }
  }

    function createLine (startPoint, endPoint, path, options) {

      if(!options) options = ToolSet['line'];

      if(!path){
        path = makeShape("path", { "class":'shape line', fill:"rgba(255,255,255,0.01)" });
        curShapeID = +new Date+Math.random();
        document.querySelector('svg.canvas').appendChild( path );
        path.setAttribute("data-id", curShapeID );
      }
      var d = 'M'+startPoint.join(',')+' '+endPoint.join(',');

      var swidth = options['stroke-width']||2;
      var highlight = options.highLight;

      var attr = {"d":d, "stroke-linecap":"round", "stroke-linejoin":"miter", "stroke-miterlimit":"4", stroke:options['stroke']||'#f00', "stroke-width": highlight ? swidth*4 : swidth , "opacity": highlight?0.5:1 }
      
      for(var i in attr){
        path.setAttribute(i, attr[i]);
      }

      path.setAttribute("marker-start", bit_check(options.arrow, 0x1) ? "url(#triangle)" : "none" );
      path.setAttribute("marker-end", bit_check(options.arrow, 0x2) ? "url(#triangle)" : "none" );

      path.setAttribute("data-tool", 'line' );
      path.setAttribute("data-startpoint", JSON.stringify( startPoint ) );
      path.setAttribute("data-endpoint", JSON.stringify( endPoint ) );
      path.setAttribute("data-options", JSON.stringify( options ) );


    }


    function createRect (startPoint, endPoint, path, options) {

      if(!options) options = ToolSet['rect'];
      
      if(!path){
        path = makeShape("rect", { "class":'shape rect', fill:"rgba(255,255,255,0.01)" });
        curShapeID = +new Date+Math.random();
        document.querySelector('svg.canvas').appendChild( path );
        path.setAttribute("data-id", curShapeID );
      }

      var swidth = options['stroke-width']||2;

      var x = Math.min(startPoint[0], endPoint[0]);
      var y = Math.min(startPoint[1], endPoint[1]);
      var w = Math.abs( startPoint[0] - endPoint[0] );
      var h = Math.abs( startPoint[1] - endPoint[1] );

      var attr = {"x":x, "y":y, "width":w, "height":h, "stroke-linecap":"round", "stroke-linejoin":"miter", "stroke-miterlimit":"4", stroke:options['stroke']||'#f00', "stroke-width": swidth }
      
      for(var i in attr){
        path.setAttribute(i, attr[i]);
      }

      path.setAttribute("data-tool", 'rect' );
      path.setAttribute("data-startpoint", JSON.stringify( startPoint ) );
      path.setAttribute("data-endpoint", JSON.stringify( endPoint ) );
      path.setAttribute("data-options", JSON.stringify( options ) );


    }



    function createSVGText (startPoint, endPoint, path, options) {

      if(!options) options = ToolSet['text'];
      console.log(options);
      if(!path){
        path = makeShape("text", { "class":'shape text' });
        curShapeID = +new Date+Math.random();
        document.querySelector('svg.canvas').appendChild( path );
        path.setAttribute("data-id", curShapeID );
      }

      var attr = {"x":endPoint[0], "y":endPoint[1], "fill":options.fill, "font-family": options['font-family'], "font-size": options['font-size'] }
      
      for(var i in attr){
        path.setAttribute(i, attr[i]);
      }

      path.innerHTML = "TEOWTIJIO";

      path.setAttribute("data-tool", 'text' );
      path.setAttribute("data-startpoint", JSON.stringify( startPoint ) );
      path.setAttribute("data-endpoint", JSON.stringify( endPoint ) );
      path.setAttribute("data-options", JSON.stringify( options ) );


    }

    function createText (startPoint, endPoint, path, options) {

      if(!options) options = ToolSet['text'];

      if(!path){
        path = $('<textarea class="text"></textarea>');
        path = $('<input class="text"/>');
        curShapeID = +new Date+Math.random();
        $('#textCon').append( path );
        path.attr("data-id", curShapeID );
      }
      var offset = $('#textCon').offset();

      var attr = {"left":endPoint[0] - offset.left, "top":endPoint[1] - offset.top, "color":options.fill, "font-family": options['font-family'], "font-size": options['font-size'] }
      
      $(path).css(attr);

      path.val( "TEOWTIJIO" );

      path.attr("data-tool", 'text' );
      path.attr("data-startpoint", JSON.stringify( startPoint ) );
      path.attr("data-endpoint", JSON.stringify( endPoint ) );
      path.attr("data-options", JSON.stringify( options ) );

      path.on("focus", function  () {
        $(this).addClass('editing');
      }).on("blur", function  (e) {
        setTimeout(function  () {
          $(e.target).removeClass('editing');
        }, 300);
      });

      /*  // dblclick to trigger
      path.on('dblclick', function () {
          path.attr('contentEditable', 'true');
          path.blur();
          path.focus();
      });
      */


    }

    function createCircle (startPoint, endPoint, path, options) {

      if(!options) options = ToolSet['circle'];
      
      if(!path){
        path = makeShape("ellipse", { "class":'shape circle', fill:"rgba(255,255,255,0.01)" });
        curShapeID = +new Date+Math.random();
        document.querySelector('svg.canvas').appendChild( path );
        path.setAttribute("data-id", curShapeID );
      }

      var swidth = options['stroke-width']||2;

      var x = Math.min(startPoint[0], endPoint[0]);
      var y = Math.min(startPoint[1], endPoint[1]);
      var w = Math.abs( startPoint[0] - endPoint[0] );
      var h = Math.abs( startPoint[1] - endPoint[1] );
      var rx = w/2;
      var ry = h/2;
      var cx = x+rx;
      var cy = y+ry;


      var attr = {"cx":cx, "cy":cy, "rx":rx, "ry":ry, "stroke-linecap":"round", "stroke-linejoin":"miter", "stroke-miterlimit":"4", stroke:options['stroke']||'#f00', "stroke-width": swidth }
      
      for(var i in attr){
        path.setAttribute(i, attr[i]);
      }

      path.setAttribute("data-tool", 'circle' );
      path.setAttribute("data-startpoint", JSON.stringify( startPoint ) );
      path.setAttribute("data-endpoint", JSON.stringify( endPoint ) );
      path.setAttribute("data-options", JSON.stringify( options ) );


    }





    function createPath (rPath, path, options) {

        if(!options) options = ToolSet['curve'];

        var L = rPath.length;

        var t, d='';
        var startP = rPath[0];
        var endP = startP;

        if(!rPath || !L) return;


        for(var i=0; i<rPath.length; i++){
          var p=rPath[i];

          if ( 0 == i ) {
            d = "M" + p[0] + "," + p[1];
          } else if ( 1 == i ) {
            d += " R" + p[0] + "," + p[1];
          } else {
            d += " " + p[0] + "," + p[1];
          }
        }


        //Auto Close:
        if( L>5 )

        if( (options.autoClose&0x1)!=0 ){ // && calcDist(startP, p)<50
          //drawing rect LineTo way.
          d+=" M" + p[0] + "," + p[1];
          d+=" L" + startP[0] + "," + startP[1];
        } else if( (options.autoClose&0x2)!=0) {
            
            d += calcInterpo(rPath, 10);
            //drawing circle Curve way.
            //rPath = rPath.concat( _interpo.slice(1) );
        }

        d = parsePath( d,true, 10 );
        if( !/undefined|NaN/.test(d) ){
            
            if(!path){
              path = makeShape("path", { "class":'shape curve', fill:"rgba(255,255,255,0.01)" });
              curShapeID = +new Date+Math.random();
              document.querySelector('svg.canvas').appendChild( path );
              path.setAttribute("data-id", curShapeID );
              path.setAttribute("data-path", JSON.stringify( rPath ) );
            }

            var attr = {"d":d, "stroke-linecap":"round", "stroke-linejoin":"miter", "stroke-miterlimit":"4", stroke:options['stroke']||'#f00', "stroke-width":options['stroke-width']||2, }
            
            for(var i in attr){
              path.setAttribute(i, attr[i]);
            }

            path.setAttribute("data-tool", 'curve' );
            path.setAttribute("data-options", JSON.stringify( options ) );

            //arrow: 0x0 no arrow, 0x1: start arrow, 0x2: end arrow
            path.setAttribute("marker-start", bit_check(options.arrow, 0x1) ? "url(#triangle)" : "none" );
            path.setAttribute("marker-end", bit_check(options.arrow, 0x2) ? "url(#triangle)" : "none" );


        } else {

        }

        return path;
    }

    function addSelectionList (el, isNew) {
      if( $(el).data('hl') )return;
      $(el).data('hl', 1);
      $(el).attr('data-oldTrans', getTranslateXY(el).join(',') );
      if(isNew) $(el).get(0).setAttribute('newHL', 1);
      updateToolBox();
    }

    function updateToolBox () {
      var theTool, maxt=0, tool={};
      $('[data-hl]').each( function(){ var t= this.dataset.tool; tool[t] = tool[t]?tool[t]+1:1; } );
      for(var i in tool){
        if(tool[i]>maxt){
          maxt = tool[i];
          theTool = i;
        }
      }
      setTool(theTool);
    }

    function getTranslateXY(obj)
    {
        var style = obj.style, transform = style.transform || style.webkitTransform || style.mozTransform;
        var transform =obj.getAttribute('transform');
        if(!transform) return [0,0];
		var zT = transform.match(/translate\(\s*([-0-9]+[\w%]*)\s*,\s*([-0-9]+[\w%]*)\s*\)/);
        return zT ? [ parseInt(zT[1]), parseInt(zT[2]) ] : [0,0];
    }

    function calcInterpo (rPath, tension) {
      //interpolation using Curve to close the path.
      //https://github.com/epistemex/cardinal-spline-js
      var d="";
      var L=rPath.length;
      var _seg=2;
      var _tension= tension||0;
      var _ps = Math.floor(L/2);
      var points=[];

      for(var c=0, i=_ps; !(c>0 && i>_ps) ; i++) {
        if(i==L){
          c++;
          i=0;
        }
        points.push( rPath[i][0], rPath[i][1] );
      }
      var res = getCurvePoints( points, _tension, _seg );

      var _resStart = (_ps-1+L%2)*_seg*2 ;
      var _resLen = _seg*2;

      var _interpo=[]
      for(var i = _resStart; i <= _resStart+_resLen; i += 2){
        _interpo.push([ res[i], res[i+1] ]);
      }

      d+=" C"+_interpo[1][0]+","+_interpo[1][1];
      d+=" "+_interpo[1][0]+","+_interpo[1][1];
      d+=" "+_interpo[2][0]+","+_interpo[2][1];
      return d;
      //end of interpo
    }

    function bit_set(a,b) { return a |= (b)}
    function bit_clear(a,b) { return a &= ~(b)}
    function bit_flip(a,b) { return a ^= (b)}
    function bit_check(a,b) { return (a & (b)) !=0 }



// Function: getPathBBox
// Get correct BBox for a path in Webkit
// Converted from code found here:
// http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
//
// Parameters:
// path - The path DOM element to get the BBox for
//
// Returns:
// A BBox-like object
var getPathBBox = function(path) {
  var seglist = path.pathSegList;
  var tot = seglist.numberOfItems;

  var bounds = [[], []];
  var start = seglist.getItem(0);
  var P0 = [start.x, start.y];

  var i;
  for (i = 0; i < tot; i++) {
    var seg = seglist.getItem(i);

    if(typeof seg.x === 'undefined') {continue;}

    // Add actual points to limits
    bounds[0].push(P0[0]);
    bounds[1].push(P0[1]);

    if(seg.x1) {
      var P1 = [seg.x1, seg.y1],
        P2 = [seg.x2, seg.y2],
        P3 = [seg.x, seg.y];

      var j;
      for (j = 0; j < 2; j++) {

        var calc = function(t) {
          return Math.pow(1-t,3) * P0[j]
            + 3 * Math.pow(1-t,2) * t * P1[j]
            + 3 * (1-t) * Math.pow(t, 2) * P2[j]
            + Math.pow(t,3) * P3[j];
        };

        var b = 6 * P0[j] - 12 * P1[j] + 6 * P2[j];
        var a = -3 * P0[j] + 9 * P1[j] - 9 * P2[j] + 3 * P3[j];
        var c = 3 * P1[j] - 3 * P0[j];

        if (a == 0) {
          if (b == 0) {
            continue;
          }
          var t = -c / b;
          if (0 < t && t < 1) {
            bounds[j].push(calc(t));
          }
          continue;
        }
        var b2ac = Math.pow(b,2) - 4 * c * a;
        if (b2ac < 0) {continue;}
        var t1 = (-b + Math.sqrt(b2ac))/(2 * a);
        if (0 < t1 && t1 < 1) {bounds[j].push(calc(t1));}
        var t2 = (-b - Math.sqrt(b2ac))/(2 * a);
        if (0 < t2 && t2 < 1) {bounds[j].push(calc(t2));}
      }
      P0 = P3;
    } else {
      bounds[0].push(seg.x);
      bounds[1].push(seg.y);
    }
  }

  var x = Math.min.apply(null, bounds[0]);
  var w = Math.max.apply(null, bounds[0]) - x;
  var y = Math.min.apply(null, bounds[1]);
  var h = Math.max.apply(null, bounds[1]) - y;
  return {
    'x': x,
    'y': y,
    'width': w,
    'height': h
  };
};


/**
 * Returns a 15 degree angle coordinate associated with the two given
 * coordinates
 * @param {number} x1 - First coordinate's x value
 * @param {number} x2 - Second coordinate's x value
 * @param {number} y1 - First coordinate's y value
 * @param {number} y2 - Second coordinate's y value
 * @returns {AngleCoord15}
*/
var snapToAngle = function (x1, y1, x2, y2) {
  var snap = Math.PI / 12; // 15 degrees
  var dx = x2 - x1;
  var dy = y2 - y1;
  var angle = Math.atan2(dy, dx);
  var dist = Math.sqrt(dx * dx + dy * dy);
  var snapangle = Math.round(angle / snap) * snap;

  return {
    x: x1 + dist * Math.cos(snapangle),
    y: y1 + dist * Math.sin(snapangle),
    a: snapangle
  };
};


/**
 * Check if two rectangles (BBoxes objects) intersect each other
 * @param {SVGRect} r1 - The first BBox-like object
 * @param {SVGRect} r2 - The second BBox-like object
 * @returns {boolean} True if rectangles intersect
 */
var rectsIntersect = function (r1, r2) {
  return r2.x < (r1.x + r1.width) &&
    (r2.x + r2.width) > r1.x &&
    r2.y < (r1.y + r1.height) &&
    (r2.y + r2.height) > r1.y;
};


function disableSelection(node){      
    $(node).addClass('unselectable');
    $(node).attr("unselectable","on");
    $(node).attr('disabled', 'disabled');
}   

function enableSelection(node){      
    $(node).removeClass('unselectable');
    $(node).attr("unselectable",null);
    $(node).attr('disabled', null);
}   



(function ($) {
$.fn.disableSelection = function () {
    return this.each(function () {
        if (typeof this.onselectstart != 'undefined') {
            this.onselectstart = function() { return false; };
        } else if (typeof this.style.MozUserSelect != 'undefined') {
            this.style.MozUserSelect = 'none';
        } else {
            this.onmousedown = function() { return false; };
            this.onmousemove = function() { return false; };
        }
    });
};
})(Zepto);


  </script>

</body>
</html>